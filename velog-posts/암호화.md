<h1 id="양방향-단방향-알고리즘">양방향 단방향 알고리즘</h1>
<ul>
<li>양방향 알고리즘: 암호화된 암호문을 복호화 할 수 있다.<ul>
<li>대칭키(비공개키), 비대칭키(공개키)</li>
</ul>
</li>
<li>단방향 알고리즘: 암호화는 수행하지만 절대로 복호화가 불가능한 알고리즘이다.<ul>
<li>Hash 방식<h1 id="대칭키비공개키-비대칭키공개키-방식">대칭키(비공개키), 비대칭키(공개키) 방식</h1>
</li>
</ul>
</li>
<li>대칭키(비공개키) 방식<ul>
<li>암호화 복호화시 모두 동일한 키를 사용</li>
<li>장점: 속도가 빠르다.</li>
<li>단점: 송신자 수신자 모두 동일한 키를 공유하기 때문에, 키 전송 시 보안 문제가 발생할 수 있다.<ul>
<li>AES(Advanced Encryption Standard): 현재 가장 널리 사용되는 대칭키 암호화 방식으로, 보안성과 속도 모두 우수함</li>
<li>DES(Data Encryption Standard): 과거 많이 사용되었으나, 보안성이 약해 현재는 잘 사용되지 않음</li>
</ul>
</li>
</ul>
</li>
<li>비대칭키(공개키) 방식<ul>
<li>암호화 복호화에 서로 다른 키가 사용되는 암호화 방식. 하나의 키는 공개키로 사용</li>
<li>공개키는 누구나 접근할 수 있고, 개인키는 비밀로 유지</li>
<li>공개키로 암호화한 데이터는 개인키로만 복호화 가능</li>
<li>개인키로 암호화한 데이터는 공개키로만 복호화 가능</li>
<li>장점: 보안성이 좋고 전자서명과 같은 인증 방식에서 사용 가능, 키 관리가 용이하다.</li>
<li>단점: 암호화, 복호화 과정이 상대적으로 느림<ul>
<li>RSA (Rivest-Shamir-Adleman): 가장 널리 사용되는 비대칭키 알고리즘.</li>
<li>DSA (Digital Signature Algorithm): 디지털 서명에 주로 사용.</li>
<li>ECC (Elliptic Curve Cryptography): 같은 보안 수준에서 더 작은 키를 사용하여 성능이 우수함.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="대칭키-암호화">대칭키 암호화</h1>
<h2 id="des-data-encryption-standard">DES (Data Encryption Standard)</h2>
<p>DES는 1970년대 미국 국립표준기술연구소(NIST)가 제정한 대칭키 알고리즘으로, 초기에는 데이터 보호 표준으로 널리 사용되었다.</p>
<ul>
<li>키 길이: 56비트의 비밀키를 사용</li>
<li>블록 크기: 64비트 블록 단위로 데이터를 암호화</li>
<li>암호화 과정: 16번의 반복 라운드를 거쳐 데이터를 암호화</li>
<li>보안성: 56비트의 키 길이 때문에 현대의 컴퓨팅 성능으로 <strong>무차별 대입 공격(brute force)</strong>에 매우 취약함<h2 id="des2-double-des">DES2 (Double DES)</h2>
DES2는 기존 DES의 보안성을 보안하기 위해 두 개의 DES 알고리즘을 연속적으로 적용한 방식이다.</li>
<li>동작 방식:<ol>
<li>첫 번째 DES 암호화: 평문을 첫 번째 키(K1)로 암호화</li>
<li>두 번째 DES 암호화: 암호화된 결과를 두 번째 키(K2)로 다시 암호화</li>
</ol>
</li>
<li>키 길이: 112비트 (56비트 + 56비트)</li>
<li>보안성: DES 보다 보안성이 높지만 <strong>Meet-in-the-Middle 공격</strong>에 취약하여 실제로는 DES보다 크게 안전하지 않음<h2 id="des3-triple-des">DES3 (Triple DES)</h2>
DES3는 기존 DES의 단점을 극복하기 위해 3번의 DES 알고리즘을 적용한 방식이다.</li>
<li>동작 방식: <ol>
<li>첫 번째 DES 암호화: 평문을 첫 번째 키(K1)로 암호화</li>
<li>두 번째 DES 암호화: 암호화된 결과를 두 번째 키(K2)로 다시 복호화</li>
<li>세 번째 DES 암호화: 다시 세 번째 키(K3)로 암호화하여 최종 암호문 생성</li>
</ol>
</li>
<li>키 길이:<ul>
<li>2키 Triple DES: 두 개의 56비트 키 사용. (총 112비트)</li>
<li>3키 Tirple DES: 세 개의 56비트 키 사용. (총 168비트)</li>
</ul>
</li>
<li>보안성: DES3는 3번의 DES 알고리즘을 적용하기 때문에 DES나 DES2보다 훨씬 안전하다.</li>
</ul>
<h2 id="aes-advanced-encryption-standard">AES (Advanced Encryption Standard)</h2>
<p>AES는 미국 국립표준기술연구소(NIST)에서 제정한 대칭키 알고리즘으로, 현재 가장 널리 사용되는 대칭 암호화 표준이다.</p>
<ul>
<li>키 길이: 128비트, 192비트, 256비트 (세 가지 옵션 제공)</li>
<li>블록 크기: 128비트 (고정)</li>
<li>암호화 메커니즘: Substitution-Permutation Network(SPN) 구조를 사용</li>
<li>라운드 수: 키 길이에 따라 10, 12, 14 라운드</li>
<li>용도: 데이터 암호화, SSL/TLS, 파일 및 디스크 암호화, 무선 네트워크(WPA2), 데이터베이스 암호화</li>
<li>보안성: AES는 현재까지 강력한 보안성을 제공하며, 대부분의 대칭키 암호화에서 표준으로 사용됨</li>
</ul>
<h2 id="seed">SEED</h2>
<p>한국인터넷진흥원(KISA)에서 개발한 대칭키 알고리즘으로 한국 내의 금융 및 공공기관 시스템에서 주로 사용된다.</p>
<ul>
<li>키 길이: 128비트</li>
<li>블록 크기: 128비트</li>
<li>암호화 메커니즘: Feistel 구조를 사용하여 16라운드 반복</li>
<li>용도: 한국 내의 금융 보안, 전자금융거래, 공공기관 정보 보호</li>
<li>보안성: AES와 유사한 수준의 보안성을 제공, 한국에서만 주로 사용<blockquote>
<p>Feistel 구조 (Feistel Network)는 대칭키 암호화 알고리즘에서 널리 사용되는 암호화 구조로, 데이터를 두 개의 반으로 나누고 반복적인 라운드를 통해 데이터를 암호화 및 복호화하는 방식이다. (좌측 절반과 우측 절반을 서로 바꾸면서 암호화 과정을 수행, 좌측 절반은 변하지 않으며, 우측 절반을 암호화 함수와 연산하여 좌측 절반과 결합)</p>
</blockquote>
</li>
</ul>
<h1 id="비대칭키-암호화">비대칭키 암호화</h1>
<h2 id="rsa-rivest-shamir-adleman">RSA (Rivest-Shamir-Adleman)</h2>
<p>RSA는 공개키 암호화 알고리즘의 대표적인 방식으로 두 개의 키(공개키, 개인키)를 사용하여 데이터를 암호화 및 복호화한다.</p>
<ul>
<li>키 길이: 1024비트, 2048비트, 4098비트</li>
<li>블록 크기: 키 길이에 따라 달라짐(일반적으로 RSA 키 길이 - 11)</li>
<li>암호화 메커니즘: 큰 소수의 곱셈과 모듈러 연산을 기반으로 함</li>
<li>용도: 키 교환, 디지털 서명, 전자 메일 암호화, 인증서 발급</li>
<li>보안성: 키 길이가 길어질수록 보안성이 높아지나, 암호화/복호화 속도가 느림. 현재는 최소 2048비트 이상을 권장</li>
</ul>
<h2 id="ecelliptic-curve-타원-곡선-암호화">EC(Elliptic Curve, 타원 곡선 암호화)</h2>
<p>EC는 타원 곡선 수학을 사용하여 RSA보다 더 짧은 키 길이로 높은 보안성을 제공한다.</p>
<ul>
<li>키 길이: 160비트, 224비트, 256비트, 384비트, 521비트</li>
<li>블록 크기: 키 길이와 동일</li>
<li>암호화 메커니즘: 타원 곡선 위에 점들을 이용하여 공개키 및 개인키 연산</li>
<li>용도: 키 교환, 데이터 암호화, 디지털 서명, IoT 장비, 모바일 기기에서 사용</li>
<li>보안성: ECC 알고리즘의 256비트 키는 RSA의 3072비트 키와 유사한 보안성을 제공. 작은 키 길이로 인해 연산 효율성이 높음</li>
</ul>
<h2 id="ecdsa-elliptic-curve-digital-signature-algorithm">ECDSA (Elliptic Curve Digital Signature Algorithm)</h2>
<p>ECDSA는 타원 곡선 암호(ECC)를 기반으로 하는 디지털 서명 알고리즘이다.</p>
<ul>
<li>키 길이: 160비트 이상 (보통 256비트 사용)</li>
<li>블록 크기: 키 길이와 동일</li>
<li>암호화 메커니즘: 타원 곡선 수학을 사용하여 서명 생성 및 검증</li>
<li>용도: 디지털 서명, 인증서, 암호화된 데이터 검증</li>
<li>보안성: ECDSA는 ECDH(Elliptic Curve Diffie-Hellman)와 함께 사용되어 강력한 보안성을 제공. </li>
</ul>
<h1 id="인증서certificate--전자서명--인증서-체인certificate-chain">인증서(Certificate) / 전자서명 / 인증서 체인(Certificate Chain)</h1>
<h2 id="인증서certificate">인증서(Certificate)</h2>
<p>인증서는 특정 사용자나 서버의 신원을 증명하기 위해 사용되는 <strong>전자 문서</strong>이다. 공개키와 함께 소유자의 정보, 발급자의 서명, 유효 기간 등이 포함된다.</p>
<ul>
<li>구성 요소:<ul>
<li>공개키: 소유자의 공개키</li>
<li>주체 정보: 인증서의 소유자에 대한 정보 (예: 도메인 이름, 사용자 이름)</li>
<li>발급자 서명: 인증서를 발급한 인증 기관의 서명</li>
</ul>
</li>
<li>용도: SSL/TLS 통신, 이메일 보안, 코드 서명, 사용자 인증</li>
<li>종류: <ul>
<li>X.509인증서: SSL/TLS에서 가장 많이 사용되는 형식</li>
<li>CA(Certificate Authority): 인증서를 발급하고 신뢰성을 보장하는 인증 기관</li>
</ul>
</li>
<li>보안성: 인증서를 통해 신뢰할 수 있는 통신을 보장하며, 중간자 공격(man-in-the-middle attack)을 방지<h2 id="전자서명digital-signature">전자서명(Digital Signature)</h2>
전자서명은 전자 문서나 메시지에 대해 특정인의 서명을 디지털 방식으로 구현한 것이다. 암호화된 해시 값을 사용하여 데이터의 무결성과 신뢰성을 보장한다.</li>
<li>암호화 메커니즘: 비대칭키 알고리즘(예: RSA, ECDSA)를 사용하여 서명 생성</li>
<li>용도: 전자 문서, 계약서, 소프트웨어 배포, 인증서 발급</li>
<li>동작 방식:<ol>
<li>서명 생성: 개인키로 데이터의 해시 값을 암호화하여 서명 생성</li>
<li>서명 검증: 공개키로 서명을 복호화하여 원본 해시 값과 비교하여 일치 여부 확인</li>
</ol>
</li>
<li>보안성: 서명 생성 시 개인키가 유출되지 않도록 주의해야 하며, 공개키는 자유롭게 배포 가능</li>
</ul>
<h2 id="인증서-체인certificate-chain">인증서 체인(Certificate Chain)</h2>
<p>인증서 체인은 루트 인증서부터 최종 사용자 인증서까지의 계층 구조를 나타내는 일련의 인증서이다.</p>
<ul>
<li>구성:<ul>
<li>루트 인증서(Root Certificate): 최상위 인증 기관이 발급한 인증서</li>
<li>중간 인증서(Intermediate Certificate): 루트 인증서와 최종 사용자 인증서를 연결하는 중간 계층</li>
<li>최종 사용자 인증서(End-User Certificate): 특정 도메인이나 사용자에게 발급된 인증서<ul>
<li>동작 원리: SSL/TLS 통신 시, 클라이언트는 인증서 체인을 따라가며 신뢰성 검증을 수행</li>
<li>용도: 웹사이트 보안(HTTPS), 이메일 보안(S/MIME), VPN 인증</li>
<li>보안성: 중간 인증서가 유효하지 않으면 최종 인증서의 신뢰성도 상실된다. 따라서 체인 전체가 신뢰할 수 있어야 한다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="블록-암호화">블록 암호화</h1>
<p>블록 암호화는 일반적으로 데이터를 암호화하거나 복호화할 때 사용되는 기본 단위이다. 주로 대칭키 암호화 알고리즘에서 사용되며, <strong>원본 데이터(평문)를 고정된 크기의 블록으로 나눈 다음, 각 블록을 특정 암호화 알고리즘에 의해 암호화한다.</strong></p>
<ol>
<li><p>블록 크기: </p>
<ul>
<li>암호화 알고리즘에서 고정된 크기의 블록을 정의 (예: AES는 128비트 블록 크기를 사용)</li>
</ul>
</li>
<li><p>패딩(Padding): </p>
<ul>
<li>만약 데이터가 고정된 블록 크기보다 짧다면, 데이터의 길이를 맞추기 위해 추가적으로 패딩을 사용한다. 대표적인 패딩 방식으로 <strong>PKCS7</strong>와 <strong>Zero Padding</strong> 등이 있다.</li>
</ul>
</li>
<li><p>암호화 모드:</p>
<ul>
<li>동일한 블록 암호화 알고리즘이라도 암호화 모드에 따라 결과가 달라진다.<ul>
<li>ECB(Electronic Code Block): 각 블록을 독립적으로 암호화. 반복되는 데이터 패턴이 그대로 유지될 수 있어 보안에 취약</li>
<li>CBC(Cipher Block Chaining): 각 블록이 이전 블록의 암호화 결과에 의존. 초기화 백터가 필요하며 패턴 보호에 강함</li>
<li>CFB(Cipher Feedback), OFB(Output Feedback): 스트림 암호처럼 동작하며, 실시간 데이터 암호화에 유용</li>
<li>CTR(Counter): 카운터 값을 사용하여 블록을 암호화. 병렬 처리가 가능하여 성능이 좋음</li>
</ul>
</li>
</ul>
</li>
<li><p>암호화 키:</p>
<ul>
<li>블록 암호화에서 사용되는 비밀 키로, 암호화와 복호화가 동일한 키를 사용하는 대칭키 암호 방식이 일반적이다. 키 길이에 따라 보안 수준이 결정되며, 일반적으로 128비트, 192비트, 256비트 길이의 키가 사용된다. </li>
</ul>
</li>
</ol>
<h3 id="패딩padding-종류">패딩(Padding) 종류</h3>
<p>암호화 패딩은 데이터의 길이가 블록 암호화 알고리즘에서 요구하는 고정된 블록 크기와 맞지 않을 때, 그 크기를 맞추기 위해 데이터를 특정 규칙에 따라 채우는 방식이다. 블록 암호화에서는 데이터가 고정된 크기의 블록으로 나누어져야 하므로, 데이터의 길이가 블록 크기와 일치하지 않는 경우 패딩을 추가해 해당 크기를 맞춰야 한다.</p>
<ol>
<li>PKCS#7 패딩<ul>
<li>가장 널리 사용되는 패딩 방식으로, 추가해야 하는 바이트의 개수를 각 바이트에 동일하게 채워넣는다.</li>
<li>예를 들어, 블록 크기가 16바이트이고, 데이터가 10바이트라면 6바이트가 부족합니다. 이 경우 06 06 06 06 06 06으로 채워 넣는다. 만약 블록 크기와 정확히 일치한다면 16바이트(10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10)로 채운다</li>
</ul>
</li>
</ol>
<pre><code>데이터: 0x01 0x02 0x03 (3바이트)
PKCS#7 패딩: 0x01 0x02 0x03 0x05 0x05 0x05 0x05 0x05 (추가된 5바이트)</code></pre><ol start="2">
<li><p>Zero Padding</p>
<ul>
<li>부족한 바이트를 모두 0x00으로 채운다.</li>
<li>주로 문자열 데이터가 아니라 이진 데이터(binary data)를 암호화할 때 사용된다.</li>
<li>예를 들어, 10바이트의 데이터를 16바이트 블록으로 맞추기 위해 0x00 0x00 0x00 0x00 0x00 0x00으로 채운다.</li>
</ul>
</li>
</ol>
<pre><code>데이터: 0x01 0x02 0x03 (3바이트)
Zero Padding: 0x01 0x02 0x03 0x00 0x00 0x00 0x00 0x00 (추가된 5바이트)</code></pre><ol start="3">
<li>ANI X.923 패딩<ul>
<li>마지막 바이트에는 패딩 바이트의 개수를 나타내는 값을 넣고, 나머지 바이트는 0x00으로 채운다.</li>
</ul>
</li>
</ol>
<pre><code>데이터: 0x01 0x02 0x03 (3바이트)
ANSI X.923 패딩: 0x01 0x02 0x03 0x00 0x00 0x00 0x00 0x05 (추가된 5바이트, 마지막 바이트는 5)</code></pre><ol start="4">
<li>ISO/IEC 7816-4 패딩<ul>
<li>처음 패딩 바이트는 0x80으로 설정하고, 나머지 바이트는 모두 0x00으로 채운다.</li>
</ul>
</li>
</ol>
<pre><code>데이터: 0x01 0x02 0x03 (3바이트)
ISO/IEC 7816-4 패딩: 0x01 0x02 0x03 0x80 0x00 0x00 0x00 0x00 (추가된 5바이트)</code></pre><ol start="5">
<li>ISO 10126 패딩<ul>
<li>ANSI X.923과 비슷하지만, 마지막 바이트에 패딩 바이트의 개수를 표시하고, 그 이전의 바이트들은 임의의 값을 가진다. (현재는 잘 사용되지 않은 방식)<pre><code>데이터: 0x01 0x02 0x03 (3바이트)
ISO 10126 패딩: 0x01 0x02 0x03 0xA3 0x7C 0x58 0xDD 0x05 (추가된 5바이트, 마지막 바이트는 5)</code></pre></li>
</ul>
</li>
<li>Bit 패딩<ul>
<li>첫 번째 패딩 바이트를 1로 설정하고, 이후에 남은 바이트를 모두 0으로 채운다.</li>
<li>주로 스트림 암호화와 데이터 압축에서 사용된다.<pre><code>데이터: 0x01 0x02 0x03 (3바이트)
Bit Padding: 0x01 0x02 0x03 0x80 0x00 0x00 0x00 0x00 (추가된 5바이트)</code></pre></li>
</ul>
</li>
</ol>
<h1 id="비밀번호-암호화">비밀번호 암호화</h1>
<blockquote>
<p>Hash: 단방향 암호화 기법
Encryption: 양방향 암호화 기법
비밀번호를 저장할 때는 탈취될 가능성이 있기 때문에 평문을 암호화하는 것은 가능하지만 다시 평문으로 복호화하는 것은 불가능한 <strong>단방향 암호화 방식</strong>을 사용한다.</p>
</blockquote>
<ol>
<li><p>MD5(Message Digest Algorithm 5)
MD5는 1992년에 개발된 해시 함수로, 입력 데이터(파일, 텍스트 등)를 128비트(16바이트)의 고정된 길이의 해시 값으로 변환한다. MD5는 빠른 속도를 제공하지만 보안이 취약하여 현재는 보안용으로는 사용되지 않고 무결성 검사나 파일 비교 등 비보안 용도로만 사용된다.</p>
</li>
<li><p>SHA(Secure Hash Algorithm)
SHA는 고정된 크기의 해시 값을 생성하기 위한 해시 알고리즘이다. SHA 알고리즘은 데이터 무결성 확인, 디지털 서명, 비밀번호 보호 및 다양한 보안 응용 프로그램에서 사용되는 무작위성을 가지고 있는 해시 함수이다.
SHA 알고리즘은 여러 버전이 있으며, 각각 다른 출력 크기와 보안 수준을 제공한다.</p>
<ul>
<li><p>SHA-1</p>
<ul>
<li>출력 크기: 160비트(40자리 16진수 문자열)</li>
<li>한때 널리 사용되었으나, 보안 취약점(충돌 가능성)이 발견되어 더 이상 암호화 용도로 권장하지 않는다.</li>
</ul>
</li>
<li><p>SHA-2 (SHA-224, SHA-256, SHA-384, SHA-512)</p>
<ul>
<li>출력 크기: SHA-256은 256비트, SHA-512는 512비트</li>
<li>현재 널리 사용되는 보안 해시 알고리즘. 충돌 저항성이 강하고 보안 수준이 높음</li>
</ul>
</li>
<li><p>SHA-3</p>
<ul>
<li>출력 크기: 다양한 출력 크기(224, 256, 384, 512비트)</li>
<li>최신 해시 표준으로, SHA-2보다 더 복잡한 알고리즘을 사용하여 보안성이 더운 강화됐다.</li>
</ul>
</li>
</ul>
<ol start="3">
<li>Bcrypt
Bcrypt는 1999년 Niels Provos와 David Mazieres에 의해 설계되었으며, 내부적으로 Blowfish 암호 알고리즘을 기반으로 하고 있다. Bcrypt는 보안 강화를 위해 <strong>작업 비용 인자(Cost Factor)</strong>를 조절하여 해시 계산에 필요한 시간을 늘릴 수 있도록 설계되었다. 즉, 시간이 지남에 따라 하드웨어 성능이 향상되더라도 해시 생성이 느려지도록 설정하여 <strong>브루트 포스(무차별 대입) 공격</strong>에 대한 저항성을 유지할 수 있다. 또한, Bcrypt는 각 비밀번호마다 <strong>랜덤한 솔트(salt)</strong>를 생성하여 같은 비밀번호라도 서로 다른 해시 값을 가지도록 해, <strong>무차별 대입 공격</strong>과 <strong>레인보우 테이블 공격</strong>을 효과적으로 방어한다. 이러한 이유로 Bcrpyt는 현재 비밀번호 해싱에 가장 널리 사용되는 알고리즘 중 하나로, 다양한 언어와 환경에서 쉽게 구현할 수 있다.</li>
</ol>
</li>
</ol>
<blockquote>
<p>  Salt(솔트)란?
솔트란 비밀번호 해싱(Hashing) 과정에서 추가되는 <strong>랜덤한 데이터</strong>로, 비밀번호 해시를 더욱 안전하게 만들기 위한 보안 기법이다. 솔트는 해시를 생성하기 전에 비밀번호 앞이나 위에 랜덤하게 붙여줌으로써, 동일한 비밀번호라도 항상 다른 해시 값이 생성되도록 한다. 예를 들어, 비밀번호 password가 주어졌을 때, 솔트 abc123을 붙이면 passwordabc123이 되며, 솔트 xyz456을 붙이면 passwordxyz456이 되어 완전히 다른 해시 값을 생성한다.</p>
</blockquote>
<blockquote>
<p>무차별 대입 공격(Brute-Force Attack): 가능한 모든 비밀번호 조합을 하나씩 대입하여 원래 비밀번호를 찾아내는 공격 방식
레인보우 테이블 공격(Rainbow Table Attack): 미리 계산된 해시 값과 비밀번호 쌍을 저장한 테이블을 이용해 해시 값으로부터 원래 비밀번호를 빠르게 추정하는 공격 방식</p>
</blockquote>
<blockquote>
<p>작업 비용인자(Cost Factor)?
작업 비용인자(Cost Factor)는 해시 연산의 반복 횟수를 증가시켜 해시 계산에 더 많은 시간과 자원을 사용하게 많들어, 공격자가 <strong>브루트 포스 공격(무차별 대입 공격)</strong>을 시도할 때 비용을 크게 증가시킨다. 브루트 포스 공격은 가능한 모든 비밀번호 조합을 시도하여 해시 값을 역추적하는 방식인데, 해시 연산이 빠르면 공격자가 여러 비밀번호를 빠르게 시도할 수 있다. 하지만, 작업 비용 인자가 높아지면 해시 하나를 생성하는 데 걸리는 시간이 기하급수적으로 증가하기 때문에, 공격자가 단순한 비밀번호 하나를 검증하는 데 더 많은 시간을 소모하게 된다.</p>
</blockquote>
<h4 id="bcypt-암호화-과정">Bcypt 암호화 과정</h4>
<p>  <img alt="" src="https://velog.velcdn.com/images/sunnamgung8/post/609d15f4-4569-473f-ba4f-5df6f231bef2/image.png" /></p>
<p>  <img alt="" src="https://velog.velcdn.com/images/sunnamgung8/post/a57fcf54-1ded-445d-89b7-fa14f514506f/image.png" /></p>
<p>위에 이미지 처럼 전처리 과정(Salt)와 반복 횟수를 더해서 Output(Digest) 값을 만든다.</p>
<p><img alt="" src="https://velog.velcdn.com/images/sunnamgung8/post/3d66c914-a9f3-49ce-a870-8a1c760ae034/image.png" /></p>